const L="/assets/index.ts-iS5H637O.js";class D{dbName;storeName;db;initPromise;constructor(s,r){this.dbName=s,this.storeName=r,this.db=null,this.initPromise=this._open()}_open(){return new Promise((s,r)=>{const t=indexedDB.open(this.dbName,1);t.onerror=()=>r(t.error),t.onsuccess=()=>{this.db=t.result,s(this.db)},t.onupgradeneeded=a=>{const o=a.target.result;o.objectStoreNames.contains(this.storeName)||o.createObjectStore(this.storeName)}})}async getAll(){return await this.initPromise,new Promise((s,r)=>{const o=this.db.transaction([this.storeName],"readonly").objectStore(this.storeName).getAll();o.onsuccess=()=>s(o.result),o.onerror=()=>r(o.error)})}async getAllKeys(){return await this.initPromise,new Promise((s,r)=>{if(!this.db){r(new Error("DB not initialized"));return}const o=this.db.transaction([this.storeName],"readonly").objectStore(this.storeName).getAllKeys();o.onsuccess=()=>s(o.result),o.onerror=()=>r(o.error)})}async set(s,r){return await this.initPromise,new Promise((t,a)=>{if(!this.db){a(new Error("DB not initialized"));return}const d=this.db.transaction([this.storeName],"readwrite").objectStore(this.storeName).put(r,s);d.onsuccess=()=>t(),d.onerror=()=>a(d.error)})}async delete(s){return await this.initPromise,new Promise((r,t)=>{if(!this.db){t(new Error("DB not initialized"));return}const n=this.db.transaction([this.storeName],"readwrite").objectStore(this.storeName).delete(s);n.onsuccess=()=>r(),n.onerror=()=>t(n.error)})}async clear(){return await this.initPromise,new Promise((s,r)=>{if(!this.db){r(new Error("DB not initialized"));return}const o=this.db.transaction([this.storeName],"readwrite").objectStore(this.storeName).clear();o.onsuccess=()=>s(),o.onerror=()=>r(o.error)})}}class ${cache;maxTabs;maxBytes;currentBytes;accessOrder;storage;ready;constructor(s=30,r=20*1024*1024){this.cache=new Map,this.maxTabs=s,this.maxBytes=r,this.currentBytes=0,this.accessOrder=[],this.storage=new D("TabSwitcherDB","screenshots"),this.ready=this._restoreFromStorage()}async _restoreFromStorage(){try{const s=await this.storage.getAllKeys();if(s.length===0)return;const r=await this.storage.getAll();s.forEach((t,a)=>{const o=r[a];o&&typeof t=="number"&&o.data&&(this.cache.set(t,o),this.currentBytes+=o.size)}),this.accessOrder=Array.from(this.cache.entries()).sort((t,a)=>a[1].timestamp-t[1].timestamp).map(t=>t[0]),console.log(`[CACHE] Restored ${this.cache.size} screenshots from storage`)}catch(s){console.error("[CACHE] Failed to restore from storage:",s)}}get(s){if(!this.cache.has(s))return null;this.accessOrder=this.accessOrder.filter(t=>t!==s),this.accessOrder.unshift(s);const r=this.cache.get(s);return r.timestamp=Date.now(),this.storage.set(s,r).catch(t=>console.warn("Failed to update timestamp",t)),r}set(s,r){const t=this._estimateSize(r);if(this.cache.has(s)){const o=this.cache.get(s).size;this.currentBytes-=o}for(;(this.cache.size>=this.maxTabs||this.currentBytes+t>this.maxBytes)&&this.cache.size>0;)this._evictLRU();const a={data:r,size:t,timestamp:Date.now()};this.cache.set(s,a),this.currentBytes+=t,this.accessOrder=this.accessOrder.filter(o=>o!==s),this.accessOrder.unshift(s),this.storage.set(s,a).catch(o=>console.error("Failed to persist screenshot",o))}delete(s){if(!this.cache.has(s))return!1;const r=this.cache.get(s);return this.currentBytes-=r.size,this.cache.delete(s),this.accessOrder=this.accessOrder.filter(t=>t!==s),this.storage.delete(s).catch(t=>console.error("Failed to delete screenshot",t)),!0}_evictLRU(){if(this.accessOrder.length===0)return;const s=this.accessOrder.pop(),r=this.cache.get(s);r&&(this.currentBytes-=r.size,this.cache.delete(s),this.storage.delete(s).catch(t=>console.warn("Failed to evict from storage",t)),console.debug(`[LRU] Evicted tab ${s} (${(r.size/1024).toFixed(1)}KB)`))}_estimateSize(s){return Math.ceil(s.length*.75)}getStats(){return{entries:this.cache.size,bytes:this.currentBytes,maxTabs:this.maxTabs,maxBytes:this.maxBytes,utilizationPercent:(this.currentBytes/this.maxBytes*100).toFixed(1)}}clear(){this.cache.clear(),this.accessOrder=[],this.currentBytes=0,this.storage.clear().catch(s=>console.error("Failed to clear storage",s))}}const l={MAX_CACHED_TABS:30,MAX_CACHE_BYTES:20*1024*1024,MAX_SCREENSHOT_SIZE:200*1024,JPEG_QUALITY:60,CAPTURE_DELAY:100,SCREENSHOT_CACHE_DURATION:300*1e3,MAX_CAPTURES_PER_SECOND:2,THROTTLE_INTERVAL:500,PERFORMANCE_LOGGING:!0,QUALITY_TIERS:{HIGH:{quality:80,maxSize:300*1024,label:"High Quality"},NORMAL:{quality:60,maxSize:200*1024,label:"Normal"},PERFORMANCE:{quality:40,maxSize:100*1024,label:"Performance"}},DEFAULT_QUALITY_TIER:"PERFORMANCE"},m=new $(l.MAX_CACHED_TABS,l.MAX_CACHE_BYTES);let h=[];const f=new Map,g=[];let _=0,R=!1,b=null,T=l.DEFAULT_QUALITY_TIER;const I=new Set;let x=!1;const w={overlayOpenTimes:[],captureCount:0,cacheHits:0,cacheMisses:0,recordOverlayOpen(e){this.overlayOpenTimes.push(e),this.overlayOpenTimes.length>100&&this.overlayOpenTimes.shift(),console.log(`[PERF] Overlay open: ${e.toFixed(2)}ms (Target: <100ms)`)},getAverageOverlayTime(){return this.overlayOpenTimes.length===0?0:this.overlayOpenTimes.reduce((s,r)=>s+r,0)/this.overlayOpenTimes.length},logStats(){const e=m.getStats(),s=this.getAverageOverlayTime();console.log("[STATS] ═══════════════════════════════════════"),console.log(`[STATS] Cache: ${e.entries}/${e.maxTabs} tabs`),console.log(`[STATS] Memory: ${(e.bytes/1024/1024).toFixed(2)}MB / ${(e.maxBytes/1024/1024).toFixed(2)}MB (${e.utilizationPercent}%)`),console.log(`[STATS] Captures: ${this.captureCount} (Hits: ${this.cacheHits}, Misses: ${this.cacheMisses})`),console.log(`[STATS] Avg Overlay Open: ${s.toFixed(2)}ms (Target: <100ms)`),console.log("[STATS] ═══════════════════════════════════════")}};function E(e,s=!1){if(g.some(t=>t.tabId===e)||I.has(e))return;const r={tabId:e,timestamp:Date.now()};s?g.unshift(r):g.push(r),z()}async function z(){if(!(R||g.length===0)){for(R=!0;g.length>0;){const s=Date.now()-_;if(s<l.THROTTLE_INTERVAL){const t=l.THROTTLE_INTERVAL-s;await new Promise(a=>setTimeout(a,t))}const r=g.shift();if(r&&r.tabId){I.add(r.tabId);try{await M(r.tabId)}finally{I.delete(r.tabId)}}_=Date.now()}R=!1}}async function M(e,s=null){try{const r=await chrome.tabs.get(e);if(!r.active)return console.debug(`[CAPTURE] Tab ${e} is not active, skipping capture`),null;if(!O(r))return console.debug(`[CAPTURE] Tab ${e} not capturable: ${r.url}`),null;await new Promise(y=>setTimeout(y,l.CAPTURE_DELAY+50));const t=await chrome.tabs.get(e).catch(()=>null);if(!t||!t.active)return console.debug(`[CAPTURE] Tab ${e} no longer active after delay`),null;const a=s||T,o=l.QUALITY_TIERS[a]||l.QUALITY_TIERS.NORMAL,n=performance.now();let d=null;try{d=await chrome.tabs.captureVisibleTab(r.windowId,{format:"jpeg",quality:o.quality})}catch{console.debug("[CAPTURE] First attempt failed, retrying with lower quality");try{await new Promise(i=>setTimeout(i,100)),d=await chrome.tabs.captureVisibleTab(r.windowId,{format:"jpeg",quality:Math.max(30,o.quality-20)})}catch(i){return console.debug(`[CAPTURE] Retry also failed for tab ${e}:`,i.message),null}}if(!d)return console.debug(`[CAPTURE] No screenshot data for tab ${e}`),null;const c=performance.now()-n,u=m._estimateSize(d);return u>o.maxSize*1.5&&console.warn(`[CAPTURE] Screenshot large: ${(u/1024).toFixed(1)}KB (target: ${(o.maxSize/1024).toFixed(1)}KB)`),m.set(e,d),w.captureCount++,l.PERFORMANCE_LOGGING&&console.debug(`[CAPTURE] Tab ${e}: ${c.toFixed(2)}ms, ${(u/1024).toFixed(1)}KB (${o.label})`),d}catch(r){return console.debug(`[CAPTURE] Failed for tab ${e}:`,r.message),null}}function O(e){if(e.discarded||!e.url)return!1;const s=["chrome://","edge://","devtools://","view-source:"];return!(e.url&&s.some(r=>e.url.startsWith(r)))}typeof chrome<"u"&&chrome.tabs?(chrome.tabs.onActivated.addListener(async e=>{try{b=e.tabId,C=Date.now(),N(e.tabId),setTimeout(()=>{E(e.tabId,!0)},200)}catch(s){console.debug("[TAB] Error in onActivated:",s)}}),chrome.tabs.onUpdated.addListener((e,s,r)=>{try{s.status==="complete"&&r.active&&setTimeout(()=>{E(e,!0)},300)}catch(t){console.debug("[TAB] Error in onUpdated:",t)}}),chrome.tabs.onCreated.addListener(e=>{try{e.id&&f.set(e.id,Date.now())}catch(s){console.debug("[TAB] Error in onCreated:",s)}}),chrome.tabs.onRemoved.addListener(e=>{try{m.delete(e),P(e),f.delete(e),I.delete(e),console.debug(`[CLEANUP] Removed tab ${e} from cache`)}catch(s){console.debug("[TAB] Error in onRemoved:",s)}})):console.error("[INIT] chrome.tabs API not available");let C=Date.now();setInterval(async()=>{try{if(!b)return;const e=300*1e3;Date.now()-C>e&&(console.debug(`[IDLE] Tab ${b} idle > 5m, refreshing screenshot`),C=Date.now(),E(b,!0))}catch(e){console.debug("[IDLE] Error in idle check:",e)}},60*1e3);function N(e){P(e),h.unshift(e),h.length>l.MAX_CACHED_TABS*2&&(h.length=l.MAX_CACHED_TABS*2),H()}function P(e){const s=h.indexOf(e);s!==-1&&h.splice(s,1)}let S=null;function H(){S&&clearTimeout(S),S=setTimeout(()=>{chrome.storage.local.set({recentTabOrder:h.slice(0,100)}).catch(e=>console.debug("[STORAGE] Failed to save recent order:",e))},500)}async function U(){try{const e=await chrome.storage.local.get(["recentTabOrder"]);if(e.recentTabOrder&&Array.isArray(e.recentTabOrder)){const s=await chrome.tabs.query({}),r=new Set(s.map(t=>t.id));h=e.recentTabOrder.filter(t=>r.has(t)),console.log(`[INIT] Restored ${h.length} recent tab order entries`)}}catch(e){console.debug("[STORAGE] Failed to restore recent order:",e)}x=!0}typeof chrome<"u"&&chrome.commands&&chrome.commands.onCommand.addListener(e=>{(e==="show-tab-switcher"||e==="cycle-next-tab")&&B()});async function B(){m.ready&&await m.ready,x||await U();const e=performance.now();try{const s=await chrome.windows.getCurrent(),r=await chrome.tabs.query({windowId:s.id});let t=[];if(chrome.tabGroups)try{t=await chrome.tabGroups.query({windowId:s.id})}catch(i){console.debug("[GROUPS] Failed to fetch groups:",i)}const a=Date.now();r.forEach((i,A)=>{f.has(i.id)||f.set(i.id,a-(r.length-A)*1e3)});const o=Q(r),n=8,d=o.map((i,A)=>{let p=null;const F=A<n;if(O(i)&&F){const v=m.get(i.id);v?(p=v,w.cacheHits++):w.cacheMisses++}return{id:i.id,title:i.title||"Untitled",url:i.url,favIconUrl:i.favIconUrl,screenshot:p?p.data:null,pinned:i.pinned,index:i.index,active:i.active,audible:i.audible,mutedInfo:i.mutedInfo,groupId:i.groupId}}),c=t.map(i=>({id:i.id,title:i.title,color:i.color,collapsed:i.collapsed})),[u]=await chrome.tabs.query({active:!0,currentWindow:!0});if(!O(u)){console.warn("[INJECT] Cannot open overlay on protected page. Switch to a regular webpage and try again.");return}await G(u.id,{action:"showTabSwitcher",tabs:d,groups:c,activeTabId:u.id});const y=performance.now()-e;w.recordOverlayOpen(y)}catch(s){console.error("[ERROR] Failed to show tab switcher:",s)}}async function G(e,s,r=1){try{await chrome.tabs.sendMessage(e,s)}catch(t){if(r>0&&t.message&&t.message.includes("Could not establish connection")){console.log("[INJECT] Content script not ready, injecting...");try{await chrome.scripting.executeScript({target:{tabId:e},files:[L]}),await new Promise(a=>setTimeout(a,150)),await chrome.tabs.sendMessage(e,s)}catch(a){const o=a&&a.message?a.message:"";if(o.includes("cannot be scripted")||o.includes("Cannot access a chrome://")||o.includes("Cannot access a chrome-extension://")||o.includes("Cannot access")&&o.includes("URL"))console.warn("[INJECT] Cannot inject on this page (protected URL). Try on a regular webpage.");else throw a}}else throw t}}function Q(e){return[...e].sort((s,r)=>{const t=s.lastAccessed||0,a=r.lastAccessed||0;if(t&&a)return a-t;if(t)return-1;if(a)return 1;const o=s.id?h.indexOf(s.id):-1,n=r.id?h.indexOf(r.id):-1;if(o!==-1&&n!==-1)return o-n;if(o!==-1)return-1;if(n!==-1)return 1;const d=f.get(s.id)||0,c=f.get(r.id)||0;return d!==c?c-d:r.index-s.index})}typeof chrome<"u"&&chrome.runtime&&chrome.runtime.onMessage&&chrome.runtime.onMessage.addListener((e,s,r)=>(Y(e,s,r),!0));async function Y(e,s,r){try{if(!e||!e.action){console.error("[ERROR] Invalid message received:",e),r({success:!1,error:"Invalid message format"});return}switch(e.action){case"getRecentlyClosed":try{const a=Math.min(25,typeof e.maxResults=="number"?e.maxResults:10),o=await chrome.sessions.getRecentlyClosed({maxResults:25}),n=[];for(const c of o)if(c.tab)n.push({kind:"tab",sessionId:c.tab.sessionId,lastModified:c.lastModified,title:c.tab.title||"Untitled",url:c.tab.url||"",favIconUrl:c.tab.favIconUrl||""});else if(c.window&&Array.isArray(c.window.tabs))for(const u of c.window.tabs)n.push({kind:"tab",sessionId:u.sessionId||c.window.sessionId,lastModified:c.lastModified,title:u.title||"Untitled",url:u.url||"",favIconUrl:u.favIconUrl||""});else c.window&&c.window.sessionId&&n.push({kind:"window",sessionId:c.window.sessionId,lastModified:c.lastModified,title:"Window",url:"",favIconUrl:""});n.sort((c,u)=>(u.lastModified||0)-(c.lastModified||0));const d=n.slice(0,a);r({success:!0,items:d})}catch(t){console.error("[ERROR] Failed to get recently closed:",t),r({success:!1,error:t.message})}break;case"restoreSession":try{if(!e.sessionId||typeof e.sessionId!="string"){r({success:!1,error:"Invalid sessionId"});return}const t=await chrome.sessions.restore(e.sessionId);r({success:!0,restored:t})}catch(t){console.error("[ERROR] Failed to restore session:",t),r({success:!1,error:t.message})}break;case"switchToTab":if(!e.tabId||typeof e.tabId!="number"){r({success:!1,error:"Invalid tab ID"});return}try{await chrome.tabs.update(e.tabId,{active:!0}),r({success:!0})}catch(t){console.error("[ERROR] Failed to switch to tab:",t),r({success:!1,error:t.message})}break;case"closeTab":if(!e.tabId||typeof e.tabId!="number"){r({success:!1,error:"Invalid tab ID"});return}try{if(!await chrome.tabs.get(e.tabId).catch(()=>null)){console.warn("[WARNING] Tab no longer exists:",e.tabId),r({success:!1,error:"Tab no longer exists"});return}await chrome.tabs.remove(e.tabId),r({success:!0})}catch(t){console.error("[ERROR] Failed to close tab:",t),r({success:!1,error:t.message})}break;case"toggleMute":if(!e.tabId||typeof e.tabId!="number"){r({success:!1,error:"Invalid tab ID"});return}try{const a=!((await chrome.tabs.get(e.tabId)).mutedInfo?.muted??!1);await chrome.tabs.update(e.tabId,{muted:a}),r({success:!0,muted:a})}catch(t){console.error("[ERROR] Failed to toggle mute:",t),r({success:!1,error:t.message})}break;case"refreshTabList":try{await B(),r({success:!0})}catch(t){console.error("[ERROR] Failed to refresh tab list:",t),r({success:!1,error:t.message})}break;case"captureTabScreenshot":if(!e.tabId||typeof e.tabId!="number"){r({success:!1,error:"Invalid tab ID"});return}try{const t=await M(e.tabId,null);r({success:!!t,screenshot:t})}catch(t){console.error("[ERROR] Failed to capture screenshot:",t),r({success:!1,error:t.message})}break;case"getCacheStats":try{const t=m.getStats();r({success:!0,stats:t})}catch(t){console.error("[ERROR] Failed to get cache stats:",t),r({success:!1,error:t.message})}break;case"setQualityTier":try{const t=e.tier||l.DEFAULT_QUALITY_TIER;l.QUALITY_TIERS[t]?(T=t,chrome.storage.local.set({qualityTier:t}),console.log(`[SETTINGS] Quality tier changed to: ${t}`),r({success:!0,tier:t})):r({success:!1,error:"Invalid quality tier"})}catch(t){console.error("[ERROR] Failed to set quality tier:",t),r({success:!1,error:t.message})}break;case"createGroup":try{if(e.tabId&&chrome.tabs.group){const t=await chrome.tabs.group({tabIds:e.tabId});r({success:!0,groupId:t})}else r({success:!1,error:"Missing tabId or API not supported"})}catch(t){console.error("[GROUPS] Failed to create group:",t),r({success:!1,error:t.message})}break;default:console.warn("[WARNING] Unknown action:",e.action),r({success:!1,error:"Unknown action"})}}catch(t){console.error("[ERROR] Message handler failed:",t),r({success:!1,error:t.message})}}setInterval(()=>{w.logStats()},6e4);async function X(){try{await U();const e=await chrome.tabs.query({}),s=Date.now();e.forEach((t,a)=>{t.id&&!f.has(t.id)&&f.set(t.id,s-(e.length-a)*1e3)});const r=await chrome.windows.getAll();for(const t of r){const[a]=await chrome.tabs.query({windowId:t.id,active:!0});a&&a.id&&(h.indexOf(a.id)===-1&&N(a.id),b=a.id,setTimeout(()=>{a.id&&E(a.id,!0)},500))}console.log(`[INIT] Initialized ${e.length} existing tabs, ${h.length} in recent order`)}catch(e){console.error("[INIT] Failed to initialize existing tabs:",e)}}console.log("[INIT] Visual Tab Switcher initialized");chrome.storage.local.get(["qualityTier"],e=>{try{const s=e&&e.qualityTier,r=l&&l.QUALITY_TIERS;s&&r&&r[s]?(T=s,console.log(`[INIT] Loaded quality tier: ${T}`)):console.log("[INIT] Using default quality tier:",T)}catch(s){console.warn("[INIT] Failed to load quality tier, using default:",s&&s.message?s.message:s)}});setTimeout(X,100);console.log("═══════════════════════════════════════════════════════");console.log("Visual Tab Switcher - Performance Optimized");console.log("═══════════════════════════════════════════════════════");console.log(`Cache: Max ${l.MAX_CACHED_TABS} tabs, ${(l.MAX_CACHE_BYTES/1024/1024).toFixed(2)}MB`);console.log("Screenshots: Quality tiers - HIGH: 60%/200KB, NORMAL: 50%/150KB, PERF: 35%/100KB");console.log(`Rate Limit: ${l.MAX_CAPTURES_PER_SECOND} captures/sec`);console.log("Target: <100ms overlay open, <50MB memory, 60fps");console.log("═══════════════════════════════════════════════════════");
